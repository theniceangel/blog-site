# sourcemap

sourcemap 是从已转换的代码映射到原始源的文件，能够帮助浏览器在调试转换的代码的时候，重现原始源。

文件格式以 `.map` 结尾，格式如下：

```json
{
  "version": 3, // 版本
  "file": "bundle.js", // 转换后的文件名称
  "sourceRoot": "", // source 的根路径，可选值，拼接 sources 字段的最前面
  "sources": [ // 源文件列表，可能存在多个
    "index.js"
  ],
  "sourcesContent": [ // 源文件的内容，可选值，如果上述的 source 找不到，会依赖这个字段
    "console.log(1);"
  ],
  "names": [], // mappings 使用到的 names 变量
  "mappings": ";;;CAAA,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC;;;;;;" // 包含映射关系的数据
}
```

该例子通过 rollup 打包。

:::details bundle.js
```js
(function () {
	'use strict';

	console.log(1);

}());
//# sourceMappingURL=bundle.js.map

```
:::

## mappings

mappings 的规则如下：

- **通过 `;` 分割生成文件的每一行(line)**

- **通过 `,` 分割每一行的每个独立部分(segment)，比如以上的 `console`，`.`，`log` 等等**

- **每一个独立部分(segment)可能由 1个，4个或者5个 base64 字符组成，甚至可能拥有更多数量的字符**

独立部分的每个 base64 字符的含义：

- **第一个**

  **代表生成文件的列号**，每一行的第一个 segment 的列号是**绝对位置**，同一行的其他 segment 都是基于它的相对位置，这样做的好处是减少了 sourcemap 文件的体积，不过在极端情况下，比如**前后 segment 的列号相差很大**，一个 base64 的字符单元就不够用了，这样每一个独立部分拥有的字符就超过了 5 个。

- **第二个**

  在 `sources` 字段的索引值，代表这个部分属于哪个文件的代码，一般在合成文件的时候会用到，它也是相对值。

- **第三个**

  **代表原始文件的行号**，每个 segment 的行号都是基于它前一个 segment 的行号求相对值，这样做也是为了减少 sourcemap 的文件体积。

  > 如果 sources 有多个元素，每当遍历至新文件的时候，相对值就是新文件的行号与上一个文件最后的 mapping 的行号差值。比如 `a.js` 最后一个 mapping 的行号是 100， `b.js` 的第一个 mapping 的行号是 1，那么第三个值就是 -99，转化成 base64 编码单元就是 nG。

- **第四个**

  **代表原始文件的列号**，每个 segment 的列号都是基于它前一个 segment 的列号求相对值，**向右偏移为正数，向左偏移为负数**。

- **第五个**

  `names` 数组的索引。

## base64-VLQ

根据 [base64](./base64.md) 的索引表，可以得到如下的位置关系：

```js
{
  mappings: ";;;CAAA(2|0|0|0),OAAO(14|0|0|14),CAAC(2|0|0|2),GAAG(6|0|0|6),CAAC(2|0|0|2),CAAC(2|0|0|2),CAAC(2|0|0|2);;;;;;"
}
```

括号里面的位置关系是怎么计算得来的呢？这里就牵涉到 **base64-VLQ** 编码了。

VLQ 是使用任意位数的二进制来表示一个任意大的数字的一种编码方式，它的原理如下：

VLQ 利用 6 个比特进行存储，其中第一位表示**是否连续(`1 为连续，0为不连续`)**，最后一位表示**正负数(`1 为负数，0为正数`)**。也就是只有中间 4 位是用来表示大小的，可以看出一个单元可以代表的范围值是 [-15, 15]，我从网上找了一个图，来进一步阐述内部的规则。

<img :src="$withBase('/assets/vlq-demo.svg')" align="center" />

1. 对于数字 7 来说，因为它落在 [-15, 15] 之间，直接把它的二进制放在中间四位即可，得到的 vlq 的值就是 `001110`，转化成十进制就是 `parseInt('001110', 2) -> 14`，再查 base64 的编码表，也就是 `字母O`；
2. 对于数字 1200 来说，它的二进制是 `10010110000`，明显一个编码单元不够表示，所以先取**后四位**，也就是图上的**内容1**，放到 vlq 的**第一个编码单元**的**中间四位**，同时**第一个编码单元**的**第一位**是 `1` 表示后面还有编码单元。**最后一位**是 `0` 表示这是一个正数。接着取图上的**内容2**，它是 5 个比特（**如果不够5位，直接高位补0**），直接把它放到**第二个编码单元**的最后，并且在第一位补上**1**，表示后面还有编码单元，因为第一个编码单元的最后一位已经表示了**正负数**，所以第二个编码单元只需要用第一位表示**是否连续**即可，同理，第三个编码单元也是这样。最后这三个编码单元的二进制都转化成十进制就变成了 `32|43|2`，再查 base64 的编码表，也就是 `grC`；
3. 对于数字 -17 来说，它的二进制是 `-10001`，先取绝对值变成 `10001`，因为它是负数，所以**第一个编码单元**的最后一位就是 `1`，最后两个编码单元得到的 base64 值就是 `jB`

因此回到上述的例子：

```js
{
  mappings: ";;;CAAA(2|0|0|0),OAAO(14|0|0|14),CAAC(2|0|0|2),GAAG(6|0|0|6),CAAC(2|0|0|2),CAAC(2|0|0|2),CAAC(2|0|0|2);;;;;;"
}
```

将上述的 base64 反解至 VLQ 编码之前的值就得到真实的位置映射关系了。

```js
{
  mappings: ";;;CAAA(1|0|0|0),OAAO(7|0|0|7),CAAC(1|0|0|1),GAAG(3|0|0|3),CAAC(1|0|0|1),CAAC(1|0|0|1),CAAC(1|0|0|1);;;;;;"
}
mappings 开始有三个分号，代表生成文件的第四行才能映射到源文件，前三行都是凭空生成的，无法映射
// 第一个 CAAA 代表 生成文件的第四行（生成文件的第二列|index.js|源文件的第一行|源文件的第一列）
// 第二个 OAAO 代表 生成文件的第四行（生成文件的第九列|index.js|源文件的第一行|源文件的第八列）
// ...

注意：从 OAAO 开始，生成文件的列号是相对于前一个 segment 计算偏移量的，每次换行，列号都会重新计算绝对值。
源文件的行号与列号都是相对于前一个 segment 计算偏移量的，不会受换行的影响
```

这里有个 [playground](https://www.murzwin.com/base64vlq.html) 可以把 mappings 放进去，得到位置映射关系。

## sourceMappingURL 与 sourceURL

sourceMappingURL 一般用在源文件的最后面，形式如下：

```js
// js 文件的形式如下
//# sourceMappingURL=<url>

// css 文件的形式如下
/*# sourceMappingURL=<url> */
```

url 可以是一个链接地址，也可以是一个 data URI，搭配 `sourcesContent` 使用。

sourceURL 一般是用于 `eval` 场景，它的形式如下：

```
//@ sourceURL=<url>
```

具体的解释可以阅读[这篇文章](http://blog.getfirebug.com/2009/08/11/give-your-eval-a-name-with-sourceurl/)
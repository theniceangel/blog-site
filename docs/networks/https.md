# https 原理

> 本文来自于 **小林 coding**[几幅图，拿下 HTTPS](https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247487650&idx=1&sn=dfee83f6773a589c775ccd6f40491289&chksm=f98e5408cef9dd1ed900a15c27f00c811a5587ffa59a90a69a73d1794800838b6fd4b061ff9f&cur_album_id=1337204681134751744&scene=190#rd)微信公众号，其他的文章都讲的不清楚不到位

## 原理

HTTPS 采用的是**对称加密**和**非对称加密**结合的「混合加密」方式：

- 在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。

- 在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。

原因是：

- **对称加密**只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换；
- **非对称加密**使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。

## CA 证书

客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

这就存在些问题，如何保证公钥不被篡改和信任度？

所以这里就需要借助第三方权威机构 CA，也就是常说的 SSL 证书，由 CA 机构颁发。申请证书的流程图如下：

<img :src="$withBase('/assets/ca.png')" align="center" />

不同 SSL 的价格相差很多，CA 公司的主要成本构成：审核 ，验证 CSR 成本，支持成本，法律成本(保险费用，担保费用)，一些浏览器厂商还会对植入根证书列表的 CA 收费，包括上述的 CRL 和 OCSP 服务器成本。

## https 如何建立的

https 是在 TCP 与 http 之间架设了一层 SSL/TLS 协议：

<img :src="$withBase('/assets/HTTPS_OSI.jpeg')" align="center" />

### SSL/TLS 简介

SSL（Secure Sockets Layer）中文称作“安全套接层”，TLS（Transport Layer Security），中文称作“传输层安全协议”。SSL 是由网景公司（Netscape）设计的主要用于 Web 的安全传输协议，目的是为网络通信提供机密性、认证性及数据完整性保障。SSL 最初的几个版本（SSL 1.0、SSL2.0、SSL 3.0）由网景公司设计和维护，从 3.1 版本开始，SSL 协议由因特网工程任务小组（IETF）正式接管，并更名为 TLS（Transport Layer Security），发展至今已有 TLS 1.0、TLS 1.1、TLS 1.2、TLS 1.3 这几个版本。

### TLS 的 handshake

<img :src="$withBase('/assets/tls_handshake.png')" align="center" />

上图简要概述来 TLS 的握手过程，其中每一个「框」都是一个记录（record），记录是 TLS 收发数据的基本单位，类似于 TCP 里的 segment。多个记录可以组合成一个 TCP 包发送，所以**通常经过「四个消息」就可以完成 TLS 握手，也就是需要 2 个 RTT**的时延，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。

事实上，不同的密钥交换算法，TLS 的握手过程可能会有一些区别。

这里先简单介绍下密钥交换算法，因为考虑到性能的问题，所以双方在加密应用信息时使用的是对称加密密钥，而对称加密密钥是不能被泄漏的，为了保证对称加密密钥的安全性，所以使用非对称加密的方式来保护对称加密密钥的协商，这个工作就是密钥交换算法负责的。

### RSA 密钥交换算法的握手过程

传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书文件中包含一对公私钥，其中公钥会在 TLS 握手阶段传递给客户端，私钥则一直留在服务端，一定要确保私钥不能被窃取。

在 RSA 密钥协商算法中，**客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密**，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。

<img :src="$withBase('/assets/tls.jpeg')" align="center" />

1. TLS 第一次握手

客户端首先发送一个 `Client Hello` 消息，消息里面有 TLS 版本号，支持的密码套件列表，以及`客户端随机数`，它是服务端生产**会话秘钥**的材料之一。

<img :src="$withBase('/assets/tls_h1.png')" align="center" />

2. TLS 第二次握手

当服务端收到客户端的 `Client Hello` 消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成`服务端随机数`。接着返回 `Server Hello` 消息，消息里面有服务器支持的密码套件。

<img :src="$withBase('/assets/tls_h2.png')" align="center" />

就前面这两个客户端和服务端相互「打招呼」的过程，客户端和服务端就已确认了 TLS 版本和使用的密码套件，而且你可能发现客户端和服务端都会各自生成一个随机数，并且还会把随机数传递给对方。那这个随机数有啥用呢？其实这两个随机数是后续作为生成「会话密钥」的条件，所谓的`会话密钥`就是数据传输时，所使用的**对称加密密钥**。

然后，服务端为了证明自己的身份，会发送 `Server Certificate` 给客户端，这个消息里含有数字证书，接着就是验证证书，取出服务器公钥的步骤

<img :src="$withBase('/assets/tls_h2_1.png')" align="center" />

3. TLS 第三次握手

客户端验证完证书后，认为可信则继续往下走。接着，客户端就会生成一个新的随机数 (pre-master)，用服务器的 RSA 公钥加密该随机数，通过「Change Cipher Key Exchange」消息传给服务端。

<img :src="$withBase('/assets/tls_h3.png')" align="center" />

服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)。

至此，客户端和服务端双方都共享了三个随机数，分别是 `Client Random、Server Random、pre-master`。

于是，双方根据已经得到的三个随机数，生成`会话密钥（Master Secret）`，它是对称密钥，用于对后续的 HTTP 请求/响应的数据加解密。

生成完会话密钥后，然后客户端发一个「Change Cipher Spec」，告诉服务端开始使用加密方式发送消息。

<img :src="$withBase('/assets/tls_h3_1.png')" align="center" />

然后，客户端再发一个「Encrypted Handshake Message（Finishd）」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。

<img :src="$withBase('/assets/tls_h3_2.png')" align="center" />

可以发现，「Change Cipher Spec」之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。

4. TLS 第四次握手

服务器也是同样的操作，发「Change Cipher Spec」和「Encrypted Handshake Message」消息，如果双方都验证加密和解密没问题，那么握手正式完成。

最后，就用「会话密钥」加解密 HTTP 请求和响应了。

## 总结

总结以上的流程可分为以下三步：

- **客户端向服务器索要并验证服务器的公钥（包含在 CA 证书里面）**
- **双方协商生产「会话秘钥」**
- **双方采用「会话秘钥」进行加密通信**

## 额外补充——DH 密钥协商算法

使用 RSA 密钥协商算法的最大问题是不支持**前向保密**，因为服务端的私钥是固定不变的。因为一旦服务端的私钥泄露了，之前所有被第三方截获的所有 TLS 通讯密文都会被破解，因此产生了 `DH 密钥协商算法`，流程如下：

<img :src="$withBase('/assets/tls_dh.png')" align="center" />

客户端和服务端各自会生成随机数，并以此作为私钥，然后根据公开的 DH 计算公示算出各自的公钥，通过 TLS 握手双方交换**各自的公钥**，这样双方都有**自己的私钥和对方的公钥**，然后双方根据各自持有的材料算出一个随机数，这个随机数的值双方都是一样的，这就可以作为后续对称加密时使用的密钥。

DH 密钥交换过程中，即使第三方截获了 TLS 握手阶段传递的公钥，在不知道的私钥的情况下，也是无法计算出密钥的，而且每一次对称加密密钥都是`实时生成`的，实现前向保密。

但因为 DH 算法的计算效率问题，后面出现了 `ECDHE` 密钥协商算法，我们现在大多数网站使用的正是 **ECDHE** 密钥协商算法，关于 ECDHE 握手的过程，将在下一篇揭晓，尽情期待哦。

(self.webpackChunkblog_site=self.webpackChunkblog_site||[]).push([[1092],{7216:(s,n,a)=>{"use strict";a.r(n),a.d(n,{data:()=>l});const l={key:"v-1edf3add",path:"/webpack4/configuration/optimization/removeAvailableModules.html",title:"removeAvailableModules",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"源码",slug:"源码",children:[]},{level:2,title:"栗子",slug:"栗子",children:[]}],filePathRelative:"webpack4/configuration/optimization/removeAvailableModules.md",git:{updatedTime:162722505e4,contributors:[{name:"jizhi",email:"jizhi@didiglobal.com",commits:1}]}}},6855:(s,n,a)=>{"use strict";a.r(n),a.d(n,{default:()=>E});var l=a(6252);const p=(0,l.uE)('<h1 id="removeavailablemodules" tabindex="-1"><a class="header-anchor" href="#removeavailablemodules" aria-hidden="true">#</a> removeAvailableModules</h1><p>removeAvailableModules 配置用来优化 chunks，如果 chunks 的 modules 已经在 父 chunks 加载过了，那么可以将这些 modules 从 chunks 移除。在生产环境下默认开启该配置，相当于使用了 RemoveParentModulesPlugin 插件。</p><h2 id="源码" tabindex="-1"><a class="header-anchor" href="#源码" aria-hidden="true">#</a> 源码</h2><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#24292e;"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RemoveParentModulesPlugin</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">\t</span><span style="color:#B392F0;">apply</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">compiler</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">\t\tcompiler.hooks.compilation.</span><span style="color:#B392F0;">tap</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;RemoveParentModulesPlugin&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">compilation</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">\t\t\t</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">handler</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">chunks</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">chunkGroups</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// ...</span></span>\n<span class="line"><span style="color:#E1E4E8;">\t\t\t};</span></span>\n<span class="line"><span style="color:#E1E4E8;">\t\t\tcompilation.hooks.optimizeChunksBasic.</span><span style="color:#B392F0;">tap</span><span style="color:#E1E4E8;">(</span></span>\n<span class="line"><span style="color:#E1E4E8;">\t\t\t\t</span><span style="color:#9ECBFF;">&quot;RemoveParentModulesPlugin&quot;</span><span style="color:#E1E4E8;">,</span></span>\n<span class="line"><span style="color:#E1E4E8;">\t\t\t\thandler</span></span>\n<span class="line"><span style="color:#E1E4E8;">\t\t\t);</span></span>\n<span class="line"><span style="color:#E1E4E8;">\t\t\tcompilation.hooks.optimizeExtractedChunksBasic.</span><span style="color:#B392F0;">tap</span><span style="color:#E1E4E8;">(</span></span>\n<span class="line"><span style="color:#E1E4E8;">\t\t\t\t</span><span style="color:#9ECBFF;">&quot;RemoveParentModulesPlugin&quot;</span><span style="color:#E1E4E8;">,</span></span>\n<span class="line"><span style="color:#E1E4E8;">\t\t\t\thandler</span></span>\n<span class="line"><span style="color:#E1E4E8;">\t\t\t);</span></span>\n<span class="line"><span style="color:#E1E4E8;">\t\t});</span></span>\n<span class="line"><span style="color:#E1E4E8;">\t}</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span>\n<span class="line"></span></code></pre></div><p>optimizeChunksBasic 和 optimizeExtractedChunksBasic 是在 compilation.seal 阶段触发，handler 的逻辑分为以下几步：</p><ul><li><p><strong>步骤一：从 entrypoint 出发</strong></p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#24292e;"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">queue</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Queue</span><span style="color:#E1E4E8;">();</span></span>\n<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">availableModulesMap</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">WeakMap</span><span style="color:#E1E4E8;">();</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// 从 entrypoints 出发，entrypoints 是一种特殊的 chunkGroup</span></span>\n<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">chunkGroup</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> compilation.entrypoints.</span><span style="color:#B392F0;">values</span><span style="color:#E1E4E8;">()) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">  availableModulesMap.</span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">(chunkGroup, </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Set</span><span style="color:#E1E4E8;">());</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 找到子 chunkGroup</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 比如在入口文件模块里面，import(&#39;./a.js&#39;)，</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 相当于于创建一个 async chunk 以及 对应的 chunkGroup，chunkGroup 是 entrypoint 的 子节点</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">child</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> chunkGroup.childrenIterable) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    queue.</span><span style="color:#B392F0;">enqueue</span><span style="color:#E1E4E8;">(child);</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span>\n<span class="line"></span></code></pre></div><p>// TODO 补充一个 entrypoints 的概念</p><p>因为 entrypoint 是根节点，所以从它们出发，先仅仅找出第一层节点，进行入队操作。</p></li><li><p><strong>步骤二：遍历 chunkGroups，记录每个 chunkGroup 可利用的 modules，存入 availableModulesMap</strong></p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#24292e;"><code><span class="line"><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (queue.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 出队当前 chunkGroup</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">chunkGroup</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> queue.</span><span style="color:#B392F0;">dequeue</span><span style="color:#E1E4E8;">();</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 获取当前 chunkGroup 能够直接使用的 modules</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> availableModules </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> availableModulesMap.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(chunkGroup);</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> changed </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 遍历所有父 chunkGroups</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">parent</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> chunkGroup.parentsIterable) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">availableModulesInParent</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> availableModulesMap.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(parent);</span></span>\n<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (availableModulesInParent </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">undefined</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// availableModulesMap 内还未有当前 chunkGroup 的信息</span></span>\n<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (availableModules </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">undefined</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 父 chunkGroups 可以直接拿过来使用的 modules</span></span>\n<span class="line"><span style="color:#E1E4E8;">        availableModules </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Set</span><span style="color:#E1E4E8;">(availableModulesInParent);</span></span>\n<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">chunk</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> parent.chunks) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// 父 chunkGroups 自己包含的 modules</span></span>\n<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">m</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> chunk.modulesIterable) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 以上的 modules 都可以被当前 chunkGroup 使用</span></span>\n<span class="line"><span style="color:#E1E4E8;">            availableModules.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(m);</span></span>\n<span class="line"><span style="color:#E1E4E8;">          }</span></span>\n<span class="line"><span style="color:#E1E4E8;">        }</span></span>\n<span class="line"><span style="color:#E1E4E8;">        availableModulesMap.</span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">(chunkGroup, availableModules);</span></span>\n<span class="line"><span style="color:#E1E4E8;">        changed </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"><span style="color:#E1E4E8;">      } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> { </span></span>\n<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// availableModulesMap 已经有了当前 chunkGroup 的信息，什么情况下会出现呢？（标记点一）</span></span>\n<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">m</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> availableModules) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// 判断当前 chunkGroup 可用的 modules 是否在另外一个父 chunkGroup 全部找得到。</span></span>\n<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// 举个例子 chunkGroup 有 parentChunkGroup1 和 parentChunkGroup2</span></span>\n<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// 由 parentChunkGroup1 计算而来的 availableModules 含有 m1 和 m2</span></span>\n<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// 如果 parentChunkGroup2 不包含 m1 和 m2 </span></span>\n<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// 或者 parentChunkGroup2.availableModules 不包含 m1 和 m2</span></span>\n<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// 那么就不能将当前 chunkGroup 的 m1 和 m2 移除</span></span>\n<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span></span>\n<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">parent.</span><span style="color:#B392F0;">containsModule</span><span style="color:#E1E4E8;">(m) </span><span style="color:#F97583;">&amp;&amp;</span></span>\n<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">availableModulesInParent.</span><span style="color:#B392F0;">has</span><span style="color:#E1E4E8;">(m)</span></span>\n<span class="line"><span style="color:#E1E4E8;">          ) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">            availableModules.</span><span style="color:#B392F0;">delete</span><span style="color:#E1E4E8;">(m);</span></span>\n<span class="line"><span style="color:#E1E4E8;">            changed </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"><span style="color:#E1E4E8;">          }</span></span>\n<span class="line"><span style="color:#E1E4E8;">        }</span></span>\n<span class="line"><span style="color:#E1E4E8;">      }</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果当前 chunkGroup 可用的模块发生了变化</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 入队所有子 chunkGroup</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (changed) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">child</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> chunkGroup.childrenIterable) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">      queue.</span><span style="color:#B392F0;">enqueue</span><span style="color:#E1E4E8;">(child);</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span>\n<span class="line"></span></code></pre></div><p>上面的逻辑其实是一个<strong>深度遍历</strong>，从 entrypoint 的第一个子 chunkGroup 开始，统计每个 chunkGroup 的祖先节点加载过的 modules，并且记录在 availableModulesMap 这样的 WeakMap 结构里面。</p><p>回到上面的注释问题<strong>标记点一</strong>，出现这种情况的原因无非是同一个 chunkGroup 被遍历了多次，换句话说，就是有多个 parentChunkGroup，比如以下的场景：</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#24292e;"><code><span class="line"><span style="color:#6A737D;">// entry.js</span></span>\n<span class="line"><span style="color:#B392F0;">import</span><span style="color:#E1E4E8;">(</span><span style="color:#6A737D;">/* webpackChunkName: &quot;shared&quot; */</span><span style="color:#9ECBFF;">&#39;./shared.js&#39;</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"><span style="color:#B392F0;">import</span><span style="color:#E1E4E8;">(</span><span style="color:#6A737D;">/* webpackChunkName: &quot;moduleB&quot; */</span><span style="color:#9ECBFF;">&#39;./moduleB.js&#39;</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// moduleB.js</span></span>\n<span class="line"><span style="color:#B392F0;">import</span><span style="color:#E1E4E8;">(</span><span style="color:#6A737D;">/* webpackChunkName: &quot;shared&quot; */</span><span style="color:#9ECBFF;">&#39;./shared.js&#39;</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"><span style="color:#79B8FF;">module</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">exports</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;moduleB&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// shared.js</span></span>\n<span class="line"><span style="color:#79B8FF;">module</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">exports</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;shared&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// webpack.config.js</span></span>\n<span class="line"><span style="color:#79B8FF;">module</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">exports</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">  context: __dirname,</span></span>\n<span class="line"><span style="color:#E1E4E8;">  entry: </span><span style="color:#9ECBFF;">&#39;./entry.js&#39;</span><span style="color:#E1E4E8;">,</span></span>\n<span class="line"><span style="color:#E1E4E8;">  output: {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    path: path.</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">(__dirname, </span><span style="color:#9ECBFF;">&quot;dist&quot;</span><span style="color:#E1E4E8;">),</span></span>\n<span class="line"><span style="color:#E1E4E8;">    filename: </span><span style="color:#9ECBFF;">&quot;[name].js&quot;</span></span>\n<span class="line"><span style="color:#E1E4E8;">  },</span></span>\n<span class="line"><span style="color:#E1E4E8;">  optimization: {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    minimize: </span><span style="color:#79B8FF;">false</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span>\n<span class="line"></span></code></pre></div><p>入口文件包含 shared 和 moduleB chunkGroup，同时 moduleB 也包含 shared chunkGroup，经过 webpack buildGraph 之后，shared 的父 chunkGroup 就是 [entrypoint, moduleBChunkGroup]。</p><p>为了找到 moduleB chunkGroup 可移除的 modules，无非就是找到既在 entrypoint 又在 moduleBChunkGroup 加载过的 modules。</p></li><li><p><strong>步骤三：利用 availableModulesMap 信息，移除 chunks 中不必要包含的 modules</strong></p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#24292e;"><code><span class="line"><span style="color:#6A737D;">// 找到所有包含这个 module 的 chunk</span></span>\n<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getParentChunksWithModule</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">currentChunk</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">module</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">chunks</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [];</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">stack</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Set</span><span style="color:#E1E4E8;">(currentChunk.parentsIterable);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">chunk</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> stack) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (chunk.</span><span style="color:#B392F0;">containsModule</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">module</span><span style="color:#E1E4E8;">)) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">      chunks.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(chunk);</span></span>\n<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">parent</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> chunk.parentsIterable) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">        stack.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(parent);</span></span>\n<span class="line"><span style="color:#E1E4E8;">      }</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> chunks;</span></span>\n<span class="line"><span style="color:#E1E4E8;">};</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// 遍历全部 chunks</span></span>\n<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">chunk</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> chunks) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 找出 chunks 可以移除的 modules</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">availableModulesSets</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Array</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">from</span><span style="color:#E1E4E8;">(</span></span>\n<span class="line"><span style="color:#E1E4E8;">    chunk.groupsIterable,</span></span>\n<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#FFAB70;">chunkGroup</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> availableModulesMap.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(chunkGroup)</span></span>\n<span class="line"><span style="color:#E1E4E8;">  );</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (availableModulesSets.</span><span style="color:#B392F0;">some</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">s</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> s </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">undefined</span><span style="color:#E1E4E8;">)) </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">//  剔除重复的 module</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">availableModules</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span></span>\n<span class="line"><span style="color:#E1E4E8;">    availableModulesSets.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>\n<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> availableModulesSets[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]</span></span>\n<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">intersect</span><span style="color:#E1E4E8;">(availableModulesSets);</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">numberOfModules</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> chunk.</span><span style="color:#B392F0;">getNumberOfModules</span><span style="color:#E1E4E8;">();</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">toRemove</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Set</span><span style="color:#E1E4E8;">();</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 添加待删除项，numberOfModules 与 availableModules.size 的目的是</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 为了取更小的值遍历来覆盖所有的 case</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (numberOfModules </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> availableModules.size) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">m</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> chunk.modulesIterable) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (availableModules.</span><span style="color:#B392F0;">has</span><span style="color:#E1E4E8;">(m)) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">        toRemove.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(m);</span></span>\n<span class="line"><span style="color:#E1E4E8;">      }</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">m</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> availableModules) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (chunk.</span><span style="color:#B392F0;">containsModule</span><span style="color:#E1E4E8;">(m)) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">        toRemove.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(m);</span></span>\n<span class="line"><span style="color:#E1E4E8;">      }</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 移除 module</span></span>\n<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">module</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">of</span><span style="color:#E1E4E8;"> toRemove) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">module</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">rewriteChunkInReasons</span><span style="color:#E1E4E8;">(</span></span>\n<span class="line"><span style="color:#E1E4E8;">      chunk,</span></span>\n<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 找到所有含有待移除的 module 的父 chunks</span></span>\n<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">getParentChunksWithModule</span><span style="color:#E1E4E8;">(chunk, </span><span style="color:#79B8FF;">module</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"><span style="color:#E1E4E8;">    );</span></span>\n<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将 module 从 chunk 中移除</span></span>\n<span class="line"><span style="color:#E1E4E8;">    chunk.</span><span style="color:#B392F0;">removeModule</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">module</span><span style="color:#E1E4E8;">);</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span>\n<span class="line"></span></code></pre></div></li></ul><h2 id="栗子" tabindex="-1"><a class="header-anchor" href="#栗子" aria-hidden="true">#</a> 栗子</h2>',7),o=(0,l.Wm)("p",null,"通过上面这个 case 大概捋了一下源码的逻辑，不过很奇怪的是，找了很多场景，都走不到进源码 toRemove 的场景，因为在 webpack buildChunkGraph 的时候，如果父子 chunkGroup 引用同一个 module，module 会直接放父 chunkGroup 的 chunk 中，也就是说 webpack 内部已经做了这一层的优化，就好比上面的 case，chunkGroupB 是 chunkGroupA 的子元素，它们共同引用了 common module，但是在实际 buildChunkGraph 的时候，common module 只会放在 chunkGroupA 的 chunk 里面，而不会放到 chunkGroupB 的 chunk 里面",-1),e=(0,l.Wm)("p",null,"那什么场景下需要 RemoveParentModulesPlugin 的呢？先标记个 TODO 项吧。",-1),E={render:function(s,n){return(0,l.wg)(),(0,l.j4)(l.HY,null,[p,(0,l.Wm)("img",{src:s.$withBase("/assets/removeAvailableModules.png"),height:"700"},null,8,["src"]),o,e],64)}}}}]);
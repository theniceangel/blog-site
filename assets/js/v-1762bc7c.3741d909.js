(self.webpackChunkblog_site=self.webpackChunkblog_site||[]).push([[9297],{6208:(e,l,n)=>{"use strict";n.r(l),n.d(l,{data:()=>a});const a={key:"v-1762bc7c",path:"/webpack4/term/dependency&moduleFactory.html",title:"dependency、moduleFactory",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"dependency",slug:"dependency",children:[]},{level:2,title:"moduleFactory",slug:"modulefactory",children:[]},{level:2,title:"Dependency 与 ModuleFactory 集合",slug:"dependency-与-modulefactory-集合",children:[]},{level:2,title:"示意图",slug:"示意图",children:[]}],filePathRelative:"webpack4/term/dependency&moduleFactory.md",git:{updatedTime:1630856917e3,contributors:[{name:"jizhi",email:"jizhi@didiglobal.com",commits:1}]}}},4002:(e,l,n)=>{"use strict";n.r(l),n.d(l,{default:()=>k});var a=n(6252);const s=(0,a.uE)('<h1 id="dependency、modulefactory" tabindex="-1"><a class="header-anchor" href="#dependency、modulefactory" aria-hidden="true">#</a> dependency、moduleFactory</h1><h2 id="dependency" tabindex="-1"><a class="header-anchor" href="#dependency" aria-hidden="true">#</a> dependency</h2><p>在 webpack 当中，万物皆是 module，但是当一个模块依赖另外一个模块的时候，怎么描述这个关系呢？没错，<strong>依赖</strong>！</p><p>举个例子：</p><div class="language-javascript ext-js"><pre class="shiki" style="background-color:#24292e;"><code><span class="line"><span style="color:#6A737D;">// index.js</span></span>\n<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> A </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;./a&#39;</span></span>\n<span class="line"></span></code></pre></div>',5),o=(0,a.Uk)("对于 index 模块来说，它的产生，是因为在 webpack.config.js 配置了 entry 是 index 文件，而 index 模块对应的 dependency 就是 "),c=(0,a.Uk)("SingleEntryDependency"),t=(0,a.Uk)("。"),p=(0,a.uE)('<p>对于 a 模块来说，它的产生，是因为 index 模块引入了它，换言之，而 a 模块对应的 dependency 就是 HarmonyImportSpecifierDependency 与 HarmonyImportSideEffectDependency。</p><p>但是模块是直接与 dependency 关联的吗？</p><p><strong>不，它们之间还有一层 moduleFactory。</strong></p><h2 id="modulefactory" tabindex="-1"><a class="header-anchor" href="#modulefactory" aria-hidden="true">#</a> moduleFactory</h2><p>与 dependency 有直接联系的是 moduleFactory，在 webpack 源码中最常见的就是 <code>NormalModuleFactory</code>，NormalModuleFactory 的功能与它的名字相符，就是为了生成 normalModule，当然还有很多其他类型的 ModuleFactory 实例，详见下文。</p><h2 id="dependency-与-modulefactory-集合" tabindex="-1"><a class="header-anchor" href="#dependency-与-modulefactory-集合" aria-hidden="true">#</a> Dependency 与 ModuleFactory 集合</h2>',6),r=(0,a.Wm)("p",null,[(0,a.Wm)("strong",null,[(0,a.Wm)("code",null,"1. NormalModuleFactory")])],-1),d=(0,a.Wm)("p",null,"webpack 源码中最常见的 ModuleFactory 类，生成的模块是 normalModule。与它有关系的 Dependency 如下图：",-1),u=(0,a.Wm)("p",null,[(0,a.Wm)("strong",null,[(0,a.Wm)("code",null,"2. MultiModuleFactory")])],-1),y=(0,a.Wm)("p",null,"如果 webpack 的 entry 配置为数组，那么生成入口模块的 dependency 就是 MultiModuleFactory，它生成的模块是 multiModule。与它有关系的 Dependency 如下图：",-1),i=(0,a.Wm)("p",null,[(0,a.Wm)("strong",null,[(0,a.Wm)("code",null,"3. ContextModuleFactory")])],-1),m=(0,a.Wm)("p",null,"比较少见的模块生成的工厂类，生成的模块是 contextModule。在以下的场景会使用 ContextModuleFactory。与它有关系的 Dependency 如下图：",-1),h=(0,a.uE)('<div class="language-javascript ext-js"><pre class="shiki" style="background-color:#24292e;"><code><span class="line"><span style="color:#6A737D;">// 加载 template 目录下所有 ejs 格式的文件</span></span>\n<span class="line"><span style="color:#79B8FF;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;./template/&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> name </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;.ejs&#39;</span><span style="color:#E1E4E8;">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// 加载 lang 目录下所有的语言包</span></span>\n<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;./lang/&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> name </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;.js&#39;</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"></span></code></pre></div>',1),F=(0,a.Wm)("p",null,[(0,a.Wm)("strong",null,[(0,a.Wm)("code",null,"4. DllModuleFactory")])],-1),E=(0,a.Wm)("p",null,"在使用了 DllEntryPlugin 插件之后，webpack 内部就会使用 DllModuleFactory，生成的模块就是 dllModule。与它有关系的 Dependency 如下图：",-1),g=(0,a.Wm)("p",null,[(0,a.Wm)("strong",null,[(0,a.Wm)("code",null,"5. NullFactory")])],-1),W=(0,a.Wm)("p",null,"NullFactory 没有任何的特殊的意义，只是提供一个占位的功能来对齐以上的功能。很多 Dependency 都与 NullFactory 关联。",-1),f=(0,a.Wm)("h2",{id:"示意图",tabindex:"-1"},[(0,a.Wm)("a",{class:"header-anchor",href:"#示意图","aria-hidden":"true"},"#"),(0,a.Uk)(" 示意图")],-1),M=(0,a.Wm)("p",null,"用一个图来说明 Dependency, ModuleFactory, Module 的关系。",-1),b=(0,a.Wm)("p",null,"Dependency 与 ModuleFactory 的关系是保存在 compilation.dependencyFactories，它是一个 Map 结构，不同的 Dependency 关联不同的 ModuleFactory，最后生成对应的 Module 实例。",-1),k={render:function(e,l){const n=(0,a.up)("RouterLink");return(0,a.wg)(),(0,a.j4)(a.HY,null,[s,(0,a.Wm)("p",null,[o,(0,a.Wm)(n,{to:"/webpack4/internal-plugins/entry/SingleEntryPlugin.html"},{default:(0,a.w5)((()=>[c])),_:1}),t]),p,(0,a.Wm)("ul",null,[(0,a.Wm)("li",null,[r,d,(0,a.Wm)("img",{src:e.$withBase("/assets/normalModuleFactory.png")},null,8,["src"])]),(0,a.Wm)("li",null,[u,y,(0,a.Wm)("img",{src:e.$withBase("/assets/multi-module-factory.png")},null,8,["src"])]),(0,a.Wm)("li",null,[i,m,(0,a.Wm)("img",{src:e.$withBase("/assets/contextModuleFactory.png")},null,8,["src"]),h]),(0,a.Wm)("li",null,[F,E,(0,a.Wm)("img",{src:e.$withBase("/assets/dll-module-factory.png")},null,8,["src"])]),(0,a.Wm)("li",null,[g,W,(0,a.Wm)("img",{src:e.$withBase("/assets/null-factory.png")},null,8,["src"])])]),f,M,(0,a.Wm)("img",{src:e.$withBase("/assets/dependency-module-factory.png")},null,8,["src"]),b],64)}}}}]);
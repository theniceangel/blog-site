(self.webpackChunkblog_site=self.webpackChunkblog_site||[]).push([[7342],{2276:(e,l,s)=>{"use strict";s.r(l),s.d(l,{data:()=>t});const t={key:"v-3d93f902",path:"/networks/https.html",title:"https 原理",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"原理",slug:"原理",children:[]},{level:2,title:"CA 证书",slug:"ca-证书",children:[]},{level:2,title:"https 如何建立的",slug:"https-如何建立的",children:[{level:3,title:"SSL/TLS 简介",slug:"ssl-tls-简介",children:[]},{level:3,title:"TLS 的 handshake",slug:"tls-的-handshake",children:[]},{level:3,title:"RSA 密钥交换算法的握手过程",slug:"rsa-密钥交换算法的握手过程",children:[]}]},{level:2,title:"总结",slug:"总结",children:[]},{level:2,title:"额外补充——DH 密钥协商算法",slug:"额外补充——dh-密钥协商算法",children:[]}],filePathRelative:"networks/https.md",git:{updatedTime:1651928346e3,contributors:[{name:"jizhi",email:"jizhi@didiglobal.com",commits:1}]}}},2541:(e,l,s)=>{"use strict";s.r(l),s.d(l,{default:()=>P});var t=s(6252);const n=(0,t.Wm)("h1",{id:"https-原理",tabindex:"-1"},[(0,t.Wm)("a",{class:"header-anchor",href:"#https-原理","aria-hidden":"true"},"#"),(0,t.Uk)(" https 原理")],-1),r=(0,t.Uk)("本文来自于 "),a=(0,t.Wm)("strong",null,"小林 coding",-1),i={href:"https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247487650&idx=1&sn=dfee83f6773a589c775ccd6f40491289&chksm=f98e5408cef9dd1ed900a15c27f00c811a5587ffa59a90a69a73d1794800838b6fd4b061ff9f&cur_album_id=1337204681134751744&scene=190#rd",target:"_blank",rel:"noopener noreferrer"},h=(0,t.Uk)("几幅图，拿下 HTTPS"),c=(0,t.Uk)("微信公众号，其他的文章都讲的不清楚不到位"),d=(0,t.uE)('<h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理" aria-hidden="true">#</a> 原理</h2><p>HTTPS 采用的是<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式：</p><ul><li><p>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。</p></li><li><p>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。</p></li></ul><p>原因是：</p><ul><li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换；</li><li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li></ul><h2 id="ca-证书" tabindex="-1"><a class="header-anchor" href="#ca-证书" aria-hidden="true">#</a> CA 证书</h2><p>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><p>这就存在些问题，如何保证公钥不被篡改和信任度？</p><p>所以这里就需要借助第三方权威机构 CA，也就是常说的 SSL 证书，由 CA 机构颁发。申请证书的流程图如下：</p>',9),p=(0,t.Wm)("p",null,"不同 SSL 的价格相差很多，CA 公司的主要成本构成：审核 ，验证 CSR 成本，支持成本，法律成本(保险费用，担保费用)，一些浏览器厂商还会对植入根证书列表的 CA 收费，包括上述的 CRL 和 OCSP 服务器成本。",-1),o=(0,t.Wm)("h2",{id:"https-如何建立的",tabindex:"-1"},[(0,t.Wm)("a",{class:"header-anchor",href:"#https-如何建立的","aria-hidden":"true"},"#"),(0,t.Uk)(" https 如何建立的")],-1),u=(0,t.Wm)("p",null,"https 是在 TCP 与 http 之间架设了一层 SSL/TLS 协议：",-1),g=(0,t.Wm)("h3",{id:"ssl-tls-简介",tabindex:"-1"},[(0,t.Wm)("a",{class:"header-anchor",href:"#ssl-tls-简介","aria-hidden":"true"},"#"),(0,t.Uk)(" SSL/TLS 简介")],-1),m=(0,t.Wm)("p",null,"SSL（Secure Sockets Layer）中文称作“安全套接层”，TLS（Transport Layer Security），中文称作“传输层安全协议”。SSL 是由网景公司（Netscape）设计的主要用于 Web 的安全传输协议，目的是为网络通信提供机密性、认证性及数据完整性保障。SSL 最初的几个版本（SSL 1.0、SSL2.0、SSL 3.0）由网景公司设计和维护，从 3.1 版本开始，SSL 协议由因特网工程任务小组（IETF）正式接管，并更名为 TLS（Transport Layer Security），发展至今已有 TLS 1.0、TLS 1.1、TLS 1.2、TLS 1.3 这几个版本。",-1),S=(0,t.Wm)("h3",{id:"tls-的-handshake",tabindex:"-1"},[(0,t.Wm)("a",{class:"header-anchor",href:"#tls-的-handshake","aria-hidden":"true"},"#"),(0,t.Uk)(" TLS 的 handshake")],-1),W=(0,t.uE)('<p>上图简要概述来 TLS 的握手过程，其中每一个「框」都是一个记录（record），记录是 TLS 收发数据的基本单位，类似于 TCP 里的 segment。多个记录可以组合成一个 TCP 包发送，所以<strong>通常经过「四个消息」就可以完成 TLS 握手，也就是需要 2 个 RTT</strong>的时延，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。</p><p>事实上，不同的密钥交换算法，TLS 的握手过程可能会有一些区别。</p><p>这里先简单介绍下密钥交换算法，因为考虑到性能的问题，所以双方在加密应用信息时使用的是对称加密密钥，而对称加密密钥是不能被泄漏的，为了保证对称加密密钥的安全性，所以使用非对称加密的方式来保护对称加密密钥的协商，这个工作就是密钥交换算法负责的。</p><h3 id="rsa-密钥交换算法的握手过程" tabindex="-1"><a class="header-anchor" href="#rsa-密钥交换算法的握手过程" aria-hidden="true">#</a> RSA 密钥交换算法的握手过程</h3><p>传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书文件中包含一对公私钥，其中公钥会在 TLS 握手阶段传递给客户端，私钥则一直留在服务端，一定要确保私钥不能被窃取。</p><p>在 RSA 密钥协商算法中，<strong>客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密</strong>，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。</p>',6),T=(0,t.Wm)("ol",null,[(0,t.Wm)("li",null,"TLS 第一次握手")],-1),L=(0,t.Wm)("p",null,[(0,t.Uk)("客户端首先发送一个 "),(0,t.Wm)("code",null,"Client Hello"),(0,t.Uk)(" 消息，消息里面有 TLS 版本号，支持的密码套件列表，以及"),(0,t.Wm)("code",null,"客户端随机数"),(0,t.Uk)("，它是服务端生产"),(0,t.Wm)("strong",null,"会话秘钥"),(0,t.Uk)("的材料之一。")],-1),k=(0,t.Wm)("ol",{start:"2"},[(0,t.Wm)("li",null,"TLS 第二次握手")],-1),f=(0,t.Wm)("p",null,[(0,t.Uk)("当服务端收到客户端的 "),(0,t.Wm)("code",null,"Client Hello"),(0,t.Uk)(" 消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成"),(0,t.Wm)("code",null,"服务端随机数"),(0,t.Uk)("。接着返回 "),(0,t.Wm)("code",null,"Server Hello"),(0,t.Uk)(" 消息，消息里面有服务器支持的密码套件。")],-1),C=(0,t.Wm)("p",null,[(0,t.Uk)("就前面这两个客户端和服务端相互「打招呼」的过程，客户端和服务端就已确认了 TLS 版本和使用的密码套件，而且你可能发现客户端和服务端都会各自生成一个随机数，并且还会把随机数传递给对方。那这个随机数有啥用呢？其实这两个随机数是后续作为生成「会话密钥」的条件，所谓的"),(0,t.Wm)("code",null,"会话密钥"),(0,t.Uk)("就是数据传输时，所使用的"),(0,t.Wm)("strong",null,"对称加密密钥"),(0,t.Uk)("。")],-1),U=(0,t.Wm)("p",null,[(0,t.Uk)("然后，服务端为了证明自己的身份，会发送 "),(0,t.Wm)("code",null,"Server Certificate"),(0,t.Uk)(" 给客户端，这个消息里含有数字证书，接着就是验证证书，取出服务器公钥的步骤")],-1),b=(0,t.Wm)("ol",{start:"3"},[(0,t.Wm)("li",null,"TLS 第三次握手")],-1),H=(0,t.Wm)("p",null,"客户端验证完证书后，认为可信则继续往下走。接着，客户端就会生成一个新的随机数 (pre-master)，用服务器的 RSA 公钥加密该随机数，通过「Change Cipher Key Exchange」消息传给服务端。",-1),_=(0,t.Wm)("p",null,"服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)。",-1),w=(0,t.Wm)("p",null,[(0,t.Uk)("至此，客户端和服务端双方都共享了三个随机数，分别是 "),(0,t.Wm)("code",null,"Client Random、Server Random、pre-master"),(0,t.Uk)("。")],-1),A=(0,t.Wm)("p",null,[(0,t.Uk)("于是，双方根据已经得到的三个随机数，生成"),(0,t.Wm)("code",null,"会话密钥（Master Secret）"),(0,t.Uk)("，它是对称密钥，用于对后续的 HTTP 请求/响应的数据加解密。")],-1),v=(0,t.Wm)("p",null,"生成完会话密钥后，然后客户端发一个「Change Cipher Spec」，告诉服务端开始使用加密方式发送消息。",-1),x=(0,t.Wm)("p",null,"然后，客户端再发一个「Encrypted Handshake Message（Finishd）」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。",-1),E=(0,t.uE)('<p>可以发现，「Change Cipher Spec」之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。</p><ol start="4"><li>TLS 第四次握手</li></ol><p>服务器也是同样的操作，发「Change Cipher Spec」和「Encrypted Handshake Message」消息，如果双方都验证加密和解密没问题，那么握手正式完成。</p><p>最后，就用「会话密钥」加解密 HTTP 请求和响应了。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>总结以上的流程可分为以下三步：</p><ul><li><strong>客户端向服务器索要并验证服务器的公钥（包含在 CA 证书里面）</strong></li><li><strong>双方协商生产「会话秘钥」</strong></li><li><strong>双方采用「会话秘钥」进行加密通信</strong></li></ul><h2 id="额外补充——dh-密钥协商算法" tabindex="-1"><a class="header-anchor" href="#额外补充——dh-密钥协商算法" aria-hidden="true">#</a> 额外补充——DH 密钥协商算法</h2><p>使用 RSA 密钥协商算法的最大问题是不支持<strong>前向保密</strong>，因为服务端的私钥是固定不变的。因为一旦服务端的私钥泄露了，之前所有被第三方截获的所有 TLS 通讯密文都会被破解，因此产生了 <code>DH 密钥协商算法</code>，流程如下：</p>',9),R=(0,t.uE)("<p>客户端和服务端各自会生成随机数，并以此作为私钥，然后根据公开的 DH 计算公示算出各自的公钥，通过 TLS 握手双方交换<strong>各自的公钥</strong>，这样双方都有<strong>自己的私钥和对方的公钥</strong>，然后双方根据各自持有的材料算出一个随机数，这个随机数的值双方都是一样的，这就可以作为后续对称加密时使用的密钥。</p><p>DH 密钥交换过程中，即使第三方截获了 TLS 握手阶段传递的公钥，在不知道的私钥的情况下，也是无法计算出密钥的，而且每一次对称加密密钥都是<code>实时生成</code>的，实现前向保密。</p><p>但因为 DH 算法的计算效率问题，后面出现了 <code>ECDHE</code> 密钥协商算法，我们现在大多数网站使用的正是 <strong>ECDHE</strong> 密钥协商算法，关于 ECDHE 握手的过程，将在下一篇揭晓，尽情期待哦。</p>",3),P={render:function(e,l){const s=(0,t.up)("OutboundLink");return(0,t.wg)(),(0,t.j4)(t.HY,null,[n,(0,t.Wm)("blockquote",null,[(0,t.Wm)("p",null,[r,a,(0,t.Wm)("a",i,[h,(0,t.Wm)(s)]),c])]),d,(0,t.Wm)("img",{src:e.$withBase("/assets/ca.png"),align:"center"},null,8,["src"]),p,o,u,(0,t.Wm)("img",{src:e.$withBase("/assets/HTTPS_OSI.jpeg"),align:"center"},null,8,["src"]),g,m,S,(0,t.Wm)("img",{src:e.$withBase("/assets/tls_handshake.png"),align:"center"},null,8,["src"]),W,(0,t.Wm)("img",{src:e.$withBase("/assets/tls.jpeg"),align:"center"},null,8,["src"]),T,L,(0,t.Wm)("img",{src:e.$withBase("/assets/tls_h1.png"),align:"center"},null,8,["src"]),k,f,(0,t.Wm)("img",{src:e.$withBase("/assets/tls_h2.png"),align:"center"},null,8,["src"]),C,U,(0,t.Wm)("img",{src:e.$withBase("/assets/tls_h2_1.png"),align:"center"},null,8,["src"]),b,H,(0,t.Wm)("img",{src:e.$withBase("/assets/tls_h3.png"),align:"center"},null,8,["src"]),_,w,A,v,(0,t.Wm)("img",{src:e.$withBase("/assets/tls_h3_1.png"),align:"center"},null,8,["src"]),x,(0,t.Wm)("img",{src:e.$withBase("/assets/tls_h3_2.png"),align:"center"},null,8,["src"]),E,(0,t.Wm)("img",{src:e.$withBase("/assets/tls_dh.png"),align:"center"},null,8,["src"]),R],64)}}}}]);